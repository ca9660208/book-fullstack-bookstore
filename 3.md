# 第三章

- withAuth（認證用）HOC
  - getInitialProps 函式
  - withAuth HOC 的參數
  - 測試 withAuth
  - 登入頁面（Login）與 NProgress
  - 非同步（asynchronous）執行及 callback
    - Promise.then
    - async/await
  - 整合 Google OAuth API
    - setupGoogle 函式、verify 函式、passport 及 strategy
    - /auth/google、/oauth2callback 及 /logout Express 路由
    - User.publicFields 及 User.signInOrSignUp 函式
    - generateSlug 函式
    - this
    - GCP（Google Cloud Platform）設定與測試

---

在我們開工之前，先取得`3-begin`的程式碼。[3-begin](https://github.com/menon-pheno/fullstack-bookstore/tree/master/book/3-begin)資料夾位於[fullstack-bookstore repo](https://github.com/menon-pheno/fullstack-bookstore)`book`的目錄內。

- 如果你還沒有將 fullstack-bookstore 給 clone 下來的話，用`git clone https://github.com/menon-pheno/fullstack-bookstore`這個指令將 repo 複製到你的電腦上
- 注意：如果你想要用自己的 GitHub 帳號自己管理程式的話，你應該將我們的 repo fork 出來並且執行`git clone https://github.com/<你的 github 名稱>/fullstack-bookstore.git`。這樣你就可以將你的改動直接 push 到你的`fullstack-bookstore` repo
- 在`3-begin`的資料夾內執行`yarn`來安裝所有的套件

我們在第三章有新增幾個套件：

- `"lodash"`
- `"nprogress"`
- `"passport"`
- `"passport-google-oauth"`

看一下第三章的 [package.json](https://github.com/menon-pheno/fullstack-bookstore/blob/master/book/3-begin/package.json)。

請確定使用我們指定的套件跟版本，並忽略任何升級的警告。我們會定期更新套件且測試相容性。我們無法確保新的套件版本與目前的程式碼都相容，套件升級時有的時候會導致一些預料之外的問題。

記得將你第二章建立的 `.env` 檔案放到專案的根目錄下。到本章的尾聲時，你會另外加上 `GOOGLE_CLIENTID` 以及 `GOOGLE_CLIENTSECRET` 的環境變數到 `.env` 檔案內。

我們鼓勵且歡迎你在閱讀本章的時候，可以在我們的 GitHub repo: [https://github.com/menon-pheno/fullstack-bookstore/issues/new](https://github.com/menon-pheno/fullstack-bookstore)回報任何 bug、錯字或是任何解釋不清楚的地方。

---

在本章，我們會建立一個名為 `withAuth` 的高階元件（higher-order component, HOC）。這個 HOC 與我們的 `App` HOC 類似，會將我們的頁面給包覆起來。不同的點在於，`App` 預設上會將所有的頁面都包覆，而 `withAuth` 則是我們在 export 頁面時會特別指定是否要使用這個 HOC 來包覆該頁面。`App` 的主要責任是提供我們程式個頁面所共用的版面（layout） - 例如 Material-UI 的主題（theme）、`Header` 元件以及我們會加上的 `Notifier` 元件。而我們 `withAuth` 元件的主要責任則是檢查使用者是否有登入，並在有登入的時候將 `user` 以 prop 的方式傳入頁面元件內。

在 `withAuth` HOC 內，我們會使用 Next.js 的 `getInitialProps` 函式來取得 `user` prop 該有的值，以傳入到頁面元件內。我們在本章中也會稍微離題以更深入的探討一下 `getInitialProps` 這個 Next.js 所提供的函式。

總結一下本章會涉獵的內容，除了實作 `withAuth` HOC 以外，我們會：

- 探討 `getInitialProps` 函式
- 建立我們的 `Login` 頁面，並引用 `Nprogress` 進度條
- 學習 `Promise.then`、`async/await` 以及 `this` 的概念
- 整合 Google OAuth API

---

## withAuth（認證用）HOC

要為應用程式導入使用者認證的功能不算是個小工程。因此我們花一整章的時間來做這件事。我們首要的工作是探討並定義實作一個會將 `user` 以 prop 的方式傳到所包覆的頁面元件的 `withAuth` HOC。接著我們會稍微離題探討非同步執行程式這個主題，然後將我們的網頁程式與 Google OAuth API 整合，最後再來測試我們整個使用者驗證的流程。

本節的兩個主要目標為：

- 在 `lib/withAuth.jsx` 定義 `withAuth` HOC
- 用一個手動於 MongoDB 資料庫建立的 `User` 文件來測試我們的 `withAuth` HOC

首先，我們接下來會藉由執行 `yarn dev` 而非 `yarn dev-express` 來啟動我們的伺服器。在 `package.json` 的 `scripts` 屬性下將：

```JSON
"dev": "next",
"dev-express": "nodemon server/server.js --watch server",
```

改成：

```JSON
"dev": "nodemon server/server.js --watch server",
```

上一章的時候，我們透過 Next.js 的 `getInitialProps` 來將使用者的資訊以 prop 的方式傳入 `Index` 頁面內。如果只有這個頁面需要這個資訊，這樣做沒什麼問題。不過，我們的網頁應用程式會有多個頁面需要這個 `user` prop 來正確地顯示資訊。如果每個頁面都這樣做，那容易出錯又不好維護。

為了提升程式碼重用性，我們可以透過建立一個 HOC 來將需要使用 `user` prop 的頁面給包覆起來，並由這個 HOC 負責將 `user` prop 給傳入所包覆的頁面。所以我們建立一個 `withAuth` 並使用 `withAuth.getInitialProps` 來包覆 `Index` 及其他需要 `user` 資訊的頁面來取代我們目前直接在 `Index` 頁面使用 `Index.getInitialProps` 的方式。

我們將 `withAuth` HOC 定義在 `lib` 目錄內的 `lib/withAuth.jsx`。在 `withAuth` 元件內我們會指定幾個簡單的 boolean 參數 - 例如 `loginRequired` 來決定所包覆的頁面是否一定要通過認證（`user` 必須不是 `null` 或 `undefined`）。接這我們就是把頁面用 `withAuth` 給包起來，並且透過這些 boolean 參數來定義所包覆的頁面該有的行為。下面是一個帶入 `loginRequired: true` 的例子：

```JavaScript
export default withAuth(Index, { loginRequired: true });
```

上面這行代表 `Index` 這個頁面需要一個有登入的使用者才能造訪。

所有針對管理者（Admin）以及顧客（Customer）角色所設計的頁面都需要是一個有登入的使用者才能造訪；因此這些頁面都應該用 `loginRequired: true` 的 `withAuth` HOC 給包覆起來。在本章中，你可以將被 `withAuth` 包覆的 `Index` 頁面想成是一個使用者的專屬儀表板（dashboard）- 當使用者成功登入後被轉導到的首頁。

我們再看一次 `Index` 頁面的 export 型態：

```JavaScript
export default withAuth(Index, { loginRequired: true });
```

可以看到 `withAuth` HOC 將 `Index` 包覆起來，並且 `loginRequired` 則指定使用者必須有成功登入才能造訪此頁面。

因此，`withAuth` 這個函式會需要：

1. 頁面元件（`BaseComponent`）
2. 具有 `loginRequired` 跟 `logoutRequired` 等屬性的物件

這兩個參數。而最後 `withAuth` 會回傳一個 `App` 元件，其內容實際上是：

```JSX
<BaseComponent {...this.props} />
```

建立 `lib/withAuth.jsx` 並且先將以下的實作給填上：

```JSX
import React from 'react';
import PropTypes from 'prop-types';
import Router from 'next/router';

const globalUser = null;

export default function withAuth(
  BaseComponent,
  { loginRequired = true, logoutRequired = false } = {},
) {
  const propTypes = {
    user: PropTypes.shape({
      id: PropTypes.string,
      isAdmin: PropTypes.bool,
    }),
    isFromServer: PropTypes.bool.isRequired,
  };

  const defaultProps = {
    user: null,
  };

  class App extends React.Component {
    static async getInitialProps(ctx) {
      // 1. getInitialProps
    }

    componentDidMount() {
      // 2. componentDidMount
    }

    render() {
      // 3. render

      return (
        <>
          <BaseComponent {...this.props} />
        </>
      );
    }
  }

  App.propTypes = propTypes;
  App.defaultProps = defaultProps;

  return App;
}
```

你可能會好奇，為何 `withAuth` 是一個回傳元件的函式，但是 `pages/` 內的 `MyApp` 及 `MyDocument` HOC 卻是單純的元件。那是因為 `App` 及 `Document` 嚴格來說並不是 HOC（我們是為了不要將事情複雜化而單純叫它們 HOC） - 實際上它們是 Next.js 內建的 `App` 及 `Document` HOC 的延伸（extend）。我們定義的 `MyApp` 及 `MyDocument` 對應的各自延伸 Next.js 的 `App` 及 `Doucment` HOC。所以嚴格來說 `MyApp` 及 `MyDocument` 是 HOC 的延伸，而非 HOC。反觀我們的 `withAuth` 則是一個獨立的 HOC，可以參考 HOC 的定義：

[https://blog.jakoblind.no/simple-explanation-of-higher-order-components-hoc/#the-most-simple-hoc](https://blog.jakoblind.no/simple-explanation-of-higher-order-components-hoc/#the-most-simple-hoc)

```JSX
// 將一個元件(WrappedComponent)以參數傳入
function simpleHOC(WrappedComponent) {
    // 回傳一個新的 anonymous 元件
    return class extends React.Component {
        render() {
            return <WrappedComponent {...this.props} />;
        }
    }
}
```

我們定義 `withAuth` 的方式就跟上面是一致的。唯一的差異是我們透過 `class App extends` 然後再回傳 `return App` 而上放的範例使用 `return class extends`，這只是單純語法的不同。值得一提的是，Next.js **內部**也是如此定義 `App` 及 `Document` HOC 的。

我們在第一章就談過指定 prop 的型態以及預設值，所以在這裡就不贅述。

另外一個值得注意的是 - `<>` 是 `React.Fragment` 的簡化語法：

[https://reactjs.org/docs/fragments.html#short-syntax](https://reactjs.org/docs/fragments.html#short-syntax)

在接下來的幾個小節，我們會定義下列的函式，並且測試我們包覆了 `Index` 頁面的 `withAuth` HOC：

- `withAuth.getInitialProps`
- `withAuth.componentDidMount`
- `withAuth.render`

---

### getInitialProps 函式

我們在本節定義 `withAuth.getInitialProps` 函式。我們之前已經有使用過 `getInitialProps` 這個函式（`Index` 頁面）。Next.js 使用 [getInitialProps](https://github.com/zeit/next.js#fetching-data-and-component-lifecylce) 函式來取得頁面元件所需要的 prop 資料。HOC 及 Next.js 頁面（元件）兩者都可以使用這個函式，但是其子元件（childe component）是不允許使用此函式。子元件必須透過父元件傳入 prop 來得到資料。

`getInitialProps` 函式是設計為可以在瀏覽器以及伺服器端執行的，因此當你知道你的頁面同時有可能是伺服器渲染及瀏覽器渲染的時候，這個函式就很適用。若你的頁面只會由瀏覽器渲染，你可以透過 `componentDidMount`（或是用 hook）以取得需要的 prop 資料。

我們的 `withAuth.getInitialProps` 需要計算出 `user` 以及 `isFromServer` 的值，然後將這兩個值以 props 的方式傳到 `App` 元件內。我們的 `withAuth.getInitialProps` 函式定義如下：

```JavaScript
static async getInitialProps(ctx) {
    const isFromServer = typeof window === 'undefined';
    const user = ctx.req ? ctx.req.user && ctx.req.user.toObject() : globalUser;

    if (isFromServer && user) {
    user._id = user._id.toString();
    }

    const props = { user, isFromServer };

    if (BaseComponent.getInitialProps) {
    Object.assign(props, (await BaseComponent.getInitialProps(ctx)) || {});
    }

    return props;
}
```

`isFromServer` 被定義為 `typeof window === 'undefined'`。換言之，當頁面是伺服器渲染的時候，`typeof window === 'undefined'` 會是 `true`，也因此 `isFromServer` 會是 `true`。而我們使用 `isFromServer` 的方式如下（待會 `withAuth.componentDidMount` 也會使用到）：

```JavaScript
if (isFromServer && user) {
    user._id = user._id.toString();
}
```

這裡注意到，在伺服器端處理 `user._id` 需要多呼叫一個 `toString`，可以參考以下兩個連結：

[https://docs.mongodb.com/manual/reference/method/ObjectId.toString/](https://docs.mongodb.com/manual/reference/method/ObjectId.toString/)

[https://stackoverflow.com/questions/13104690/nodejs-mongodb-object-id-to-string](https://stackoverflow.com/questions/13104690/nodejs-mongodb-object-id-to-string)

我們來用個 `console.log()` 來驗證一下從伺服器端來的 `user._id` 並非 `string` 而是 `object`（因此需要呼叫 `toString`），不過由於我們還未將 `Index` 頁面與 `withAuth` 結合，因此我們透過 `Index.getInitialProps` 來示範，將 `Index.getInitialProps` 改成以下：

```JavaScript
Index.getInitialProps = async (ctx) => {
  const isFromServer = typeof window === 'undefined';
  const user = ctx.query ? ctx.query.user && ctx.query.user.toObject() : null;

  if (isFromServer && user) {
    console.log('Index page server getInitialProps...');
    console.log('before', typeof user._id, user._id);
    user._id = user._id.toString();
    console.log('after', typeof user._id, user._id);
  }

  return {
    user: ctx.query.user,
  };
};
```

重整你的 `http://localhost:8000` 頁面，讓它取得一個伺服器渲染的頁面，你的終端機會 log 出：

```
Index page server getInitialProps...
before object 620493d3fd9c514ea9e29eaf
after string 620493d3fd9c514ea9e29eaf
```

可以看到 `user._id` 本來是一個 `object` 的型態，因此需要呼叫 `toString` 將之轉型為 `string`。當然你看到的 `user._id` 會與我們這邊有所不同。

我們傳入了 `{loginRequired = true, logoutRequired = false}` 這個參數到我們的 `withAuth` HOC，不過我們目前 `withAuth` 的邏輯都還沒有用到這個參數。我們在下個小節即將在定義 `withAuth.componentDidMount` 以及 `withAuth.render` 時使用它們。

---

### withAuth HOC 的參數

我們在這邊討論一下 `withAuth` HOC 的 `loginRequired` 以及 `logoutRequired` 參數的作用為何。我們在第六章會另外再多加一個 `adminRequired` 參數。

我們的網頁應用程式應該如何處理已登出的使用者呢？一個好的使用體驗（user experience, UX）應該是在當已登出的使用者想要造訪一個需要登入才能使用的頁面時，將使用者導到 `Login` 頁面。換個角度來看，我們透過 `withAuth` 來指定 `Index` 頁面只能由已登入的使用者使用，而 `Login` 頁面只能由未登入的使用者使用。

因此，我們可以在 `Index` 頁面使用 `loginRequired` 為 `true` 如下：

```JavaScript
export default withAuth(Index, { loginRequired: true });
```

而 `Login` 頁面則可以將 `logoutRequired` 設為 `true` 如下：

```JavaScript
export default withAuth(Login, { logoutRequired: true });
```

我們 `lib/withAuth.jsx` 定義上面的參數如下：

```JavaScript
{ loginRequired = true, logoutRequired = false } = {}
```

這個代表說，假設我們沒有指定 `loginRequired` 的值，它預設就會是 `loginRequired: true`。因此我們只要簡單的如下調整 `Index`：

```JavaScript
export default withAuth(Index);
```

這樣就會指定 `Index` 為只能由已登入的使用者造訪。

但是我們的 `Login` 頁面仍然需要將 `logoutRequired: true` 傳入（因為 `logoutRequired` 的預設值是 `false`）。所以我們 export `Login` 頁面元件的方式依然維持為：

```JavaScript
export default withAuth(Login, { logoutRequired: true });
```

到這裡你應該了解我們為何需要 `loginRequired` 及 `logoutRequired` 這兩個參數，以及 `withAuth` 包覆頁面時何時需要傳入指定值。我們接下來就是要利用這些參數在 `withAuth` 內設定對應的邏輯。

我們將要在 `withAuth.componentDidMount` 內實作轉導的相關邏輯。

想像一下使用者造訪由 `withAuth` 包覆的 `Index` 頁面：

```JavaScript
export default withAuth(Index);
```

這代表 `loginRequired = true` 及 `logoutRequired = false`。如果使用者未登入，則 `!user` 為 `true`，那我們的應用程式會將使用者轉導至 `Login` 頁面。

當使用者想要造訪由 `withAuth` 包覆的 `Login` 頁面：

```JavaScript
export default withAuth(Login, { logoutRequired: true });
```

由於 `logoutRequired = true`，所以如果使用者已登入，則我們將會將使用者轉導至 `Index` 頁面。

將以上兩個情境結合起來：

```JavaScript
componentDidMount() {
    const { user } = this.props;

    if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
    }

    if (logoutRequired && user) {
        Router.push('/');
    }
}
```

另外，在我們上述的兩個情境轉導之前，我們也要禁止我們的網頁應用程式去渲染所造訪的網頁，因此：

```JavaScript
render() {
    const { user } = this.props;

    if (loginRequired && !logoutRequired && !user) {
        return null;
    }

    if (logoutRequired && user) {
        return null;
    }

    return (
        <>
            <BaseComponent {...this.props} />
        </>
    );
}
```

將以上的事情做完後，你的 `lib/withAuth.jsx` 應該如下：

```JSX
import React from 'react';
import PropTypes from 'prop-types';
import Router from 'next/router';

let globalUser = null;

export default function withAuth(
  BaseComponent,
  { loginRequired = true, logoutRequired = false } = {},
) {
  const propTypes = {
    user: PropTypes.shape({
      id: PropTypes.string,
      isAdmin: PropTypes.bool,
    }),
    isFromServer: PropTypes.bool.isRequired,
  };

  const defaultProps = {
    user: null,
  };

  class App extends React.Component {
    static async getInitialProps(ctx) {
      const isFromServer = typeof window === 'undefined';
      const user = ctx.req ? ctx.req.user && ctx.req.user.toObject() : globalUser;

      if (isFromServer && user) {
        user._id = user._id.toString();
      }

      const props = { user, isFromServer };

      if (BaseComponent.getInitialProps) {
        Object.assign(props, (await BaseComponent.getInitialProps(ctx)) || {});
      }

      return props;
    }

    componentDidMount() {
      const { user, isFromServer } = this.props;

      if (isFromServer) {
        globalUser = user;
      }

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      if (logoutRequired && user) {
        Router.push('/');
      }
    }

    render() {
      const { user } = this.props;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return (
        <>
          <BaseComponent {...this.props} />
        </>
      );
    }
  }

  App.propTypes = propTypes;
  App.defaultProps = defaultProps;

  return App;
}
```

這樣我們的 `withAuth` HOC 就完成了，下個小節我們就可以來測試驗證了！

---

### 測試 withAuth

到這邊，我們有個 `withAuth` HOC 的初版了。

將 `withAuth` 引入至 `Index` 頁面，並且用前面所提到的方式將頁面用 `withAuth` 包覆起來。

我們之前實作 `Index` 頁面的方式為：

- 我們是用 stateless functional component 的方式實作（見第一章）
- 頁面是透過 `Index.getInitialProps` 從伺服器取得使用者資訊（見第二章）

我們測試之前，先做幾個改變：

- 將頁面元件改以 `class...extends` 語法定義
- 移除 `Index.getInitialProps`，因為我們將會使用 `withAuth` HOC 來取得資訊

做了這些改動後，你的 `pages/index.jsx` 應該如以下：

```JSX
import React from 'react';
import PropTypes from 'prop-types';
import Head from 'next/head';

import withAuth from '../lib/withAuth';

const propTypes = {
  user: PropTypes.shape({
    displayName: PropTypes.string,
    email: PropTypes.string.isRequired,
  }),
};

const defaultProps = {
  user: null,
};

class Index extends React.Component {
  render() {
    const { user } = this.props;
    return (
      <div style={{ padding: '10px 45px' }}>
        <Head>
          <title>首頁</title>
          <meta name="說明" content="這是首頁的說明資訊" />
        </Head>
        <p>已購買書籍清單</p>
        <p>
          Email:&nbsp;
          {user.email}
        </p>
      </div>
    );
  }
}

Index.propTypes = propTypes;
Index.defaultProps = defaultProps;

export default withAuth(Index);
```

VS code 編輯器會報一個警告：

```
Component should be written as a pure function
```

你可以在類別定義的上面加上 `// eslint-disable-next-line react/prefer-stateless-function` 來消除這個警告。由於我們這頁的行為會逐漸複雜化，以類別的方式比較好說明，我們會維持使用類別的實作方式來進行。

在我們測試 `Index` 之前，把 `withAuth` 內的以下這段給暫時註記起來：

```JavaScript
if (loginRequired && !logoutRequired && !user) {
    Router.push('/login');
    return;
}
```

因為我們不要在測試中被轉導。

現在如果 `yarn dev` 並且造訪 `http://localhost:8000` 的話，你會看到：

```
TypeError: Cannot read property 'email' of null
```

這代表了我們沒有正確的從伺服器端取得 `user` 資訊。`user` 資訊來自於我們第二章所定義的 `/` Express 路由。打開 `server/server.js` 看一下我們目前的 `/` Express 路由定義：

```JavaScript
server.get('/', async (req, res) => {
    req.session.foo = 'bar';
    const user = await User.findOne({ slug: 'pheno-author' });
    app.render(req, res, '/', { user });
});
```

由於我們是將 `user` 以 `app.render` 的第四個參數傳入，這代表的是當時我們是透過 `Index.getIntialProps` 的 `ctx.query.user` 取得使用者資訊。但是注意到我們在 `withAuth` 內定義 `user` prop 的方式為：

```JavaScript
const user = ctx.req ? ctx.req.user && ctx.req.user.toObject() : globalUser;
```

這代表我們 `/` Express 路由的邏輯需要調整。我們需要透過 `ctx.req.user` 而非 `ctx.query.user` 來取得 `user` 資訊。將 `/` Express 路由修改如下：

```JavaScript
server.get('/', async (req, res) => {
    req.session.foo = 'bar';
    const user = await User.findOne({ slug: 'pheno-author' });
    req.user = user;
    app.render(req, res, '/');
});
```

值得注意的是，我們本章晚點會整合 Google OAuth API，在整合完畢後我們要把這個 Express 路由刪除。這是因為我們用來整合 Google OAuth API 的 `passport` 套件會負責將使用者資訊提供至 `req.user`，我們就不用做這個動作了。

另外，你也需要確認你的 MongoDB 資料庫內的 `users` 集合是具有 `User` MongoDB 文件的。我們在第二章有進行過這件事情，如果你沒做這個動作，請到 MongoDB Atlas，點擊 `bookstore.users` 集合，**手動**新增以下的 `User` MongoDB 文件（可以參考第二章我們所進行的步驟）：

```JSON
createdAt: 2017-12-17T02:05:57.426+00:00
email: "pheno_the_best@yahoo.com.tw"
displayName: "黃敬強"
avatarUrl: "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA..."
slug: "pheno-author"
```

現在 `yarn dev` 並造訪 `http://localhost:8000`：

![alt chapter 3 user](3-chrome-user.png)

如果你在 `Index` 頁面看得到使用者的 email，那你成功的透過 `withAuth` HOC 將 `user` 以 prop 的方式傳到 `Index` 頁面了！

---

### 登入頁面（Login）與 NProgress

我們雖然在討論 `withAuth` 時有提到 `Login` 頁面，但是我們還沒有進行 `Login` 頁面的任何實作。

我們實際 export `Login` 頁面元件的時候會將 `logoutRequired` 設定為 `true`（因為 `logoutRequired` 的預設值是 `false`）：

```JavaScript
export default withAuth(Login, { logoutRequired: true });
```

我們這次將 `Login` 頁面定義為 stateless functional component，`pages/login.jsx` 如下（如果第一章與第二章有好好吸收，這個頁面理應上不難懂）：

```JSX
import Head from 'next/head';
import Button from '@material-ui/core/Button';

import withAuth from '../lib/withAuth';
import { styleLoginButton } from '../components/SharedStyles';

const Login = () => (
  <div style={{ textAlign: 'center', margin: '0 20px' }}>
    <Head>
      <title>登入 pheno 書店</title>
      <meta name="description" content="書店登入頁面" />
    </Head>
    <br />
    <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: '400' }}>登入</p>
    <p>若沒有手動登出，將會維持登入 14 天</p>
    <br />
    <Button variant="contained" style={styleLoginButton} href="/auth/google">
      <img
        src="https://storage.googleapis.com/builderbook/G.svg"
        alt="使用 Google 登入"
        style={{ marginRight: '10px' }}
      />
      使用 Google 登入
    </Button>
  </div>
);

export default withAuth(Login, { logoutRequired: true });
```

我們之前的章節已經探討過 Next.js 的 `Head` 元件以及 Material-UI 的 `Button` 元件，這裡不贅述。值得注意的是 `使用 Google 登入` 這個按鈕是會將使用者轉導至 `/auth/google` 這個路由，藉由這個路由我們進行 Google OAuth API 的認證過程。本章晚點我們會定義一個 `/auth/google` Express 路由來讓伺服器知道當使用者造訪 `/auth/google` 時該進行什麼動作。我們第五章還會繼續探討 Express 路由。

`yarn dev` 並造訪 `http://localhost:8000/login`：

![alt Login](3-chrome-login.png)

雖然我們尚未整合 Google OAuth API，但是我們的應用程式離具有使用者登入功能又再進一步了！

讓我們現在來做一個使用者體驗的改善。我們的網頁應用程式應該要有某種視覺提示來**表示**正在進行載入的動作。當頁面正在載入，或是使用者點擊了個按鈕觸發 API 時，我們應該要讓使用者知道有進度。舉例來說，當點擊我們左上角的 logo 連結時，沒有任何視覺提示讓我們知道說路由改變了，正在載入新的頁面這個行為會是使用者不預期的。對比來說，嘗試載入下面這個網址：

[http://ricostacruz.com/nprogress/](http://ricostacruz.com/nprogress/)

這個頁面在上方有個簡潔的藍色進度條。這個進度條會讓使用者知道頁面正在載入，並且給予一個大致進度狀況的呈現。

我們也在我們的網頁應用程式加上這個 `NProgress` 進度條。本章開始時的 `yarn` 已將 `nprogress` 套件給安裝了。

我們可以選擇將 `NProgress` 進度條加在我們的 `Header` 元件或是 `App` HOC。由於所有的頁面應該都用得到進度條，所以比較好的選擇會是將進度條加在 `App` 裡面，這樣所有的頁面都會具有這個元件。

打開你的 `pages/_app.jsx`，加入兩個新的引入元件 `Router` 及 `NProgress`：

```JavaScript
import CssBaseline from '@material-ui/core/CssBaseline';
import { ThemeProvider } from '@material-ui/styles';
import App from 'next/app';
import PropTypes from 'prop-types';
import React from 'react';
import Head from 'next/head';
import Router from 'next/router';
import NProgress from 'nprogress';

import { theme } from '../lib/theme';

import Header from '../components/Header';
```

接者在 import 之後在 `Router` 的幾個事件觸發時呼叫 `NProgress.start` 及 `NProgress.done`：

```JavaScript
Router.onRouteChangeStart = () => NProgress.start();
Router.onRouteChangeComplete = () => NProgress.done();
Router.onRouteChangeError = () => NProgress.done();
```

Next.js 的路由事件（router event）可以參考以下官方文件：

[https://nextjs.org/docs/api-reference/next/router#routerevents](https://nextjs.org/docs/api-reference/next/router#routerevents)

至於 `NProgress` 的 style 主要有兩種方式可以處理：

1. 到 [https://unpkg.com/nprogress@0.2.0/nprogress.css](https://unpkg.com/nprogress@0.2.0/nprogress.css) 下載 `nprogress.css` 後將這個檔案放到 `public` 資料夾內，這樣就可以引用這個 `css` 檔

2. 將 `nprogress.min.css` 放到 CDN 上然後在 `Head` 元件內引用（可以參考我們的 `_document.jsx` 檔）：

```HTML
<link
    rel="stylesheet"
    href="https://storage.googleapis.com/builderbook/nprogress.min.css"
/>
```

你的 `href` 會跟我們的有所不同，視你上傳的位址而定。

我們會建議第二個方法，將靜態檔案透過 CDN 發布，通常效能上是比較好的。

`yarn dev` 然後造訪 `http://localhost:8000/login`，點擊左上的 logo 以及右上的`登入`連結，你會看到當路由改變的時候會有個藍色的進度條。

到這裡，我們定義了 `withAuth` HOC 以及實作了 `Login` 頁面以及做了一些使用者體驗上的優化。在我們開始相對來說較為複雜的 Google OAuth API 整合之前，我們稍微離開實作的部分，並且探討一下 `Promise` 以及 `async/await` 語法。如果你對這些概念熟悉，可以跳過下一小節。

---

### 非同步（asynchronous）執行及 callback

以前的 JavaScript 需要透過 `callback` 來確認一個非同步函式（asynchronous function）是否有執行完畢（[https://stackoverflow.com/questions/824234/what-is-a-callback-function](https://stackoverflow.com/questions/824234/what-is-a-callback-function)）。非同步函式簡單來說就是一個需要一定延遲才會完成的函式。而 callback 則是一個函式，而被以參數傳入非同步函式。

附帶一提，callback 並非只有在非同步執行的時候才能使用，也可以用來在同步執行的程式裡面使用，不過我們在這小節只探討非同步函式。

我們在整合 Google OAuth API 時會寫兩個 callback 函式（`verify` 及 `verified`）。

非同步執行的處理主要有三個方式，依據它們在 JavaScript 裡被支援的順序依序為：

1. 非同步 callback（asynchronous callback）
2. `Promise` - 透過 `Promise.then`、`Promise.catch`及 promise 鏈結（promise chaining）
3. `async/await`

從第一個方式來看，當非同步函式完成時 - callback 函式會被執行。因此，你透過 callback 函式的實際執行來判斷非同步函式的結果（透過 callback 來檢查執行是否成功）。

以下是一個 callback 函式的範例：

[https://www.freecodecamp.org/news/javascript-from-callbacks-to-async-await-1cc090ddad99/](https://www.freecodecamp.org/news/javascript-from-callbacks-to-async-await-1cc090ddad99/)

```JavaScript
doThis(andThenThis);

function andThenThis() {
    console.log('and then this');
}

function doThis(callback) {
    console.log('this first');

    callback();
}
```

到你的瀏覽器打開 `Console`，貼上上面的程式碼，按 `Enter`：

![alt Callback](3-console-callback.png)
