# 第三章

- withAuth（認證用）HOC
  - getInitialProps 函式
  - withAuth HOC 的參數
  - 測試 withAuth
  - 登入頁面（Login）與 NProgress
  - 非同步（asynchronous）執行及 callback
    - Promise.then
    - async/await
  - 整合 Google OAuth API
    - setupGoogle 函式、verify 函式、passport 及 strategy
    - /auth/google、/oauth2callback 及 /logout Express 路由
    - User.publicFields 及 User.signInOrSignUp 函式
    - generateSlug 函式
    - this
    - GCP（Google Cloud Platform）設定與測試

---

在我們開工之前，先取得`3-begin`的程式碼。[3-begin](https://github.com/menon-pheno/fullstack-bookstore/tree/master/book/3-begin)資料夾位於[fullstack-bookstore repo](https://github.com/menon-pheno/fullstack-bookstore)`book`的目錄內。

- 如果你還沒有將 fullstack-bookstore 給 clone 下來的話，用`git clone https://github.com/menon-pheno/fullstack-bookstore`這個指令將 repo 複製到你的電腦上
- 注意：如果你想要用自己的 GitHub 帳號自己管理程式的話，你應該將我們的 repo fork 出來並且執行`git clone https://github.com/<你的 github 名稱>/fullstack-bookstore.git`。這樣你就可以將你的改動直接 push 到你的`fullstack-bookstore` repo
- 在`3-begin`的資料夾內執行`yarn`來安裝所有的套件

我們在第三章有新增幾個套件：

- `"lodash"`
- `"nprogress"`
- `"passport"`
- `"passport-google-oauth"`

看一下第三章的 [package.json](https://github.com/menon-pheno/fullstack-bookstore/blob/master/book/3-begin/package.json)。

請確定使用我們指定的套件跟版本，並忽略任何升級的警告。我們會定期更新套件且測試相容性。我們無法確保新的套件版本與目前的程式碼都相容，套件升級時有的時候會導致一些預料之外的問題。

記得將你第二章建立的 `.env` 檔案放到專案的根目錄下。到本章的尾聲時，你會另外加上 `GOOGLE_CLIENTID` 以及 `GOOGLE_CLIENTSECRET` 的環境變數到 `.env` 檔案內。

我們鼓勵且歡迎你在閱讀本章的時候，可以在我們的 GitHub repo: [https://github.com/menon-pheno/fullstack-bookstore/issues/new](https://github.com/menon-pheno/fullstack-bookstore)回報任何 bug、錯字或是任何解釋不清楚的地方。

---

在本章，我們會建立一個名為 `withAuth` 的高階元件（higher-order component, HOC）。這個 HOC 與我們的 `App` HOC 類似，會將我們的頁面給包覆起來。不同的點在於，`App` 預設上會將所有的頁面都包覆，而 `withAuth` 則是我們在 export 頁面時會特別指定是否要使用這個 HOC 來包覆該頁面。`App` 的主要責任是提供我們程式個頁面所共用的版面（layout） - 例如 Material-UI 的主題（theme）、`Header` 元件以及我們會加上的 `Notifier` 元件。而我們 `withAuth` 元件的主要責任則是檢查使用者是否有登入，並在有登入的時候將 `user` 以 prop 的方式傳入頁面元件內。

在 `withAuth` HOC 內，我們會使用 Next.js 的 `getInitialProps` 函式來取得 `user` prop 該有的值，以傳入到頁面元件內。我們在本章中也會稍微離題以更深入的探討一下 `getInitialProps` 這個 Next.js 所提供的函式。

總結一下本章會涉獵的內容，除了實作 `withAuth` HOC 以外，我們會：

- 探討 `getInitialProps` 函式
- 建立我們的 `Login` 頁面，並引用 `Nprogress` 進度條
- 學習 `Promise.then`、`async/await` 以及 `this` 的概念
- 整合 Google OAuth API

---

## withAuth（認證用）HOC

要為應用程式導入使用者認證的功能不算是個小工程。因此我們花一整章的時間來做這件事。我們首要的工作是探討並定義實作一個會將 `user` 以 prop 的方式傳到所包覆的頁面元件的 `withAuth` HOC。接著我們會稍微離題探討非同步執行程式這個主題，然後將我們的網頁程式與 Google OAuth API 整合，最後再來測試我們整個使用者驗證的流程。

本節的兩個主要目標為：

- 在 `lib/withAuth.jsx` 定義 `withAuth` HOC
- 用一個手動於 MongoDB 資料庫建立的 `User` 文件來測試我們的 `withAuth` HOC

首先，我們接下來會藉由執行 `yarn dev` 而非 `yarn dev-express` 來啟動我們的伺服器。在 `package.json` 的 `scripts` 屬性下將：

```JSON
"dev": "next",
"dev-express": "nodemon server/server.js --watch server",
```

改成：

```JSON
"dev": "nodemon server/server.js --watch server",
```

上一章的時候，我們透過 Next.js 的 `getInitialProps` 來將使用者的資訊以 prop 的方式傳入 `Index` 頁面內。如果只有這個頁面需要這個資訊，這樣做沒什麼問題。不過，我們的網頁應用程式會有多個頁面需要這個 `user` prop 來正確地顯示資訊。如果每個頁面都這樣做，那容易出錯又不好維護。

為了提升程式碼重用性，我們可以透過建立一個 HOC 來將需要使用 `user` prop 的頁面給包覆起來，並由這個 HOC 負責將 `user` prop 給傳入所包覆的頁面。所以我們建立一個 `withAuth` 並使用 `withAuth.getInitialProps` 來包覆 `Index` 及其他需要 `user` 資訊的頁面來取代我們目前直接在 `Index` 頁面使用 `Index.getInitialProps` 的方式。

我們將 `withAuth` HOC 定義在 `lib` 目錄內的 `lib/withAuth.jsx`。在 `withAuth` 元件內我們會指定幾個簡單的 boolean 參數 - 例如 `loginRequired` 來決定所包覆的頁面是否一定要通過認證（`user` 必須不是 `null` 或 `undefined`）。接這我們就是把頁面用 `withAuth` 給包起來，並且透過這些 boolean 參數來定義所包覆的頁面該有的行為。下面是一個帶入 `loginRequired: true` 的例子：

```JavaScript
export default withAuth(Index, { loginRequired: true });
```

上面這行代表 `Index` 這個頁面需要一個有登入的使用者才能造訪。

所有針對管理者（Admin）以及顧客（Customer）角色所設計的頁面都需要是一個有登入的使用者才能造訪；因此這些頁面都應該用 `loginRequired: true` 的 `withAuth` HOC 給包覆起來。在本章中，你可以將被 `withAuth` 包覆的 `Index` 頁面想成是一個使用者的專屬儀表板（dashboard）- 當使用者成功登入後被轉導到的首頁。

我們再看一次 `Index` 頁面的 export 型態：

```JavaScript
export default withAuth(Index, { loginRequired: true });
```

可以看到 `withAuth` HOC 將 `Index` 包覆起來，並且 `loginRequired` 則指定使用者必須有成功登入才能造訪此頁面。

因此，`withAuth` 這個函式會需要：

1. 頁面元件（`BaseComponent`）
2. 具有 `loginRequired` 跟 `logoutRequired` 等屬性的物件

這兩個參數。而最後 `withAuth` 會回傳一個 `App` 元件，其內容實際上是：

```JSX
<BaseComponent {...this.props} />
```

建立 `lib/withAuth.jsx` 並且先將以下的實作給填上：

```JSX
import React from 'react';
import PropTypes from 'prop-types';
import Router from 'next/router';

const globalUser = null;

export default function withAuth(
  BaseComponent,
  { loginRequired = true, logoutRequired = false } = {},
) {
  const propTypes = {
    user: PropTypes.shape({
      id: PropTypes.string,
      isAdmin: PropTypes.bool,
    }),
    isFromServer: PropTypes.bool.isRequired,
  };

  const defaultProps = {
    user: null,
  };

  class App extends React.Component {
    static async getInitialProps(ctx) {
      // 1. getInitialProps
    }

    componentDidMount() {
      // 2. componentDidMount
    }

    render() {
      // 3. render

      return (
        <>
          <BaseComponent {...this.props} />
        </>
      );
    }
  }

  App.propTypes = propTypes;
  App.defaultProps = defaultProps;

  return App;
}
```

你可能會好奇，為何 `withAuth` 是一個回傳元件的函式，但是 `pages/` 內的 `MyApp` 及 `MyDocument` HOC 卻是單純的元件。那是因為 `App` 及 `Document` 嚴格來說並不是 HOC（我們是為了不要將事情複雜化而單純叫它們 HOC） - 實際上它們是 Next.js 內建的 `App` 及 `Document` HOC 的延伸（extend）。我們定義的 `MyApp` 及 `MyDocument` 對應的各自延伸 Next.js 的 `App` 及 `Doucment` HOC。所以嚴格來說 `MyApp` 及 `MyDocument` 是 HOC 的延伸，而非 HOC。反觀我們的 `withAuth` 則是一個獨立的 HOC，可以參考 HOC 的定義：

[https://blog.jakoblind.no/simple-explanation-of-higher-order-components-hoc/#the-most-simple-hoc](https://blog.jakoblind.no/simple-explanation-of-higher-order-components-hoc/#the-most-simple-hoc)

```JSX
// 將一個元件(WrappedComponent)以參數傳入
function simpleHOC(WrappedComponent) {
    // 回傳一個新的 anonymous 元件
    return class extends React.Component {
        render() {
            return <WrappedComponent {...this.props} />;
        }
    }
}
```

我們定義 `withAuth` 的方式就跟上面是一致的。唯一的差異是我們透過 `class App extends` 然後再回傳 `return App` 而上放的範例使用 `return class extends`，這只是單純語法的不同。值得一提的是，Next.js **內部**也是如此定義 `App` 及 `Document` HOC 的。

我們在第一章就談過指定 prop 的型態以及預設值，所以在這裡就不贅述。

另外一個值得注意的是 - `<>` 是 `React.Fragment` 的簡化語法：

[https://reactjs.org/docs/fragments.html#short-syntax](https://reactjs.org/docs/fragments.html#short-syntax)

在接下來的幾個小節，我們會定義下列的函式，並且測試我們包覆了 `Index` 頁面的 `withAuth` HOC：

- `withAuth.getInitialProps`
- `withAuth.componentDidMount`
- `withAuth.render`

---

### getInitialProps 函式

我們在本節定義 `withAuth.getInitialProps` 函式。我們之前已經有使用過 `getInitialProps` 這個函式（`Index` 頁面）。Next.js 使用 [getInitialProps](https://github.com/zeit/next.js#fetching-data-and-component-lifecylce) 函式來取得頁面元件所需要的 prop 資料。HOC 及 Next.js 頁面（元件）兩者都可以使用這個函式，但是其子元件（childe component）是不允許使用此函式。子元件必須透過父元件傳入 prop 來得到資料。

`getInitialProps` 函式是設計為可以在瀏覽器以及伺服器端執行的，因此當你知道你的頁面同時有可能是伺服器渲染及瀏覽器渲染的時候，這個函式就很適用。若你的頁面只會由瀏覽器渲染，你可以透過 `componentDidMount`（或是用 hook）以取得需要的 prop 資料。

我們的 `withAuth.getInitialProps` 需要計算出 `user` 以及 `isFromServer` 的值，然後將這兩個值以 props 的方式傳到 `App` 元件內。我們的 `withAuth.getInitialProps` 函式定義如下：

```JSX
static async getInitialProps(ctx) {
    const isFromServer = typeof window === 'undefined';
    const user = ctx.req ? ctx.req.user && ctx.req.user.toObject() : globalUser;

    if (isFromServer && user) {
    user._id = user._id.toString();
    }

    const props = { user, isFromServer };

    if (BaseComponent.getInitialProps) {
    Object.assign(props, (await BaseComponent.getInitialProps(ctx)) || {});
    }

    return props;
}
```
